title: 搭建自己的PHP框架，第一天
date: 2018-1-26 16:07:18
tags: 搭建框架
categories: PHP

---
** {{ title }}：** <Excerpt in index | 首页摘要>
![u=228695038,594732975&fm=27&gp=0](/img/phpFrame/u=228695038,594732975&fm=27&gp=0.jpg)
接触了一个学期的ThinkPHP基本的用法也已经熟悉了，虽然框架是现在主流的开发方式，可以很大程度上地提升开发效率，但是总觉得框架限制了自己的思维，总觉得自己变成了框架程序员，对PHP的理解不够深。没想过要用自己搭的框架开发项目，希望通过这个学习搭建一个框架，顺便补一补原生php的知识，有助于自己对主流框架有更深的理解，使用起来也能更加得心应手。
<!-- more -->
<The rest of contents | 余下全文>

### 什么是PHP框架？

框架就是通过提供一个开发Web程序的基本架构（一般的思想为MVC），PHP开发框架把PHPWeb程序开发摆到了流水线上。换句话说，PHP开发框架有助于促进[快速软件开发](https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91)（RAD），这节约了你的时间，有助于创建更为稳定的程序，并减少开发者的重复编写代码的劳动。这些框架还通过确保正确的数据库操作以及只在表现层编程的方式帮助初学者创建稳定的程序。PHP开发框架使得你可以花更多的时间去创造真正的Web程序，而不是编写重复性的代码。一般来说比较大型的公司使用自己搭建的框架，比较流行的开源PHP框架有很多，比如ThinkPHP，CI，laravel。TP在国内比较流行。

#### 框架的优点：

1.适合初学者，搭建方便，能比较容易地写出比较稳健的代码，开发效率高效。

---之后再补充---

#### 框架的缺点：

1.容易限制思维,不利于新手对php的理解

---之后再补充---

### 开发模式

单例模式：确保仅生成当前类的唯一实例

示例：
```
class Demo{
  
}
$obj1= new Demo();
$obj2= new Demo();
$obj3= new Demo();
//$obj4=clone $obj3;//引用赋值，变量的克隆，生成一个相同的，id不同的对象
/*调用三次*/
var_dump($obj1,$obj2,$obj3,$obj4);

```
查看结果：

![TIM截图20180126183735](\img\phpFrame\TIM截图20180126183735.png)

可知同一个类生成了不同的三次对象，这样非常消耗内存，实际操作中只要实例化一次。

单例模式：
```
class Demo{
  //1.创建一个私有属性，保存当前类的实例
  private static $instance = null;
  //2.构造方法私有化，禁止外部new调用
  private function __construct(){
    
  }
  //3.构造方法私有化，禁止clone方法克隆生成新的实例
  private functon __clone(){
    
  }
  //4.生成当前类的唯一实例
  public static function  getInstance(){
  //这个方法一定要是静态的公共方法，
//声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。
        /*
         * instanceof的用法：
         * 1.判断一个对象是否某个类的实例
         * 2.判断一个对象的是否实现了某个接口
        */
        //如果不是当前类的实例，那么实例化当前类创建实例
        if(!self::$instance instanceof self){
            self::$instance = new self();
        }
        return self::$instance;
    }
}
$obj1 = Demo::getInstance();
$obj2 = Demo::getInstance();
$obj3 = Demo::getInstance();
$obj4 = Demo::getInstance();
var_dump($obj1,$obj2,$obj3,$obj4);
```
查看结果：![TIM截图20180126145031](\img\phpFrame\TIM截图20180126145031.png)

实现了单例模式：确保仅生成当前类的唯一实例

#### 单例模式：封装一个数据库操作模型的操作

创建Db.php类
```
<?php

/**
 * Created by PhpStorm.
 * User: Administrator
 * Date: 2018-01-26
 * Time: 14:56
 * 数据库的基本操作
 * 1.创建当前类的单一实例
 *2.创建数据库的基本操作类
 * 使用PDO数据对象
 * PHP 数据对象 （PDO） 扩展为PHP访问数据库定义了一个轻量级的一致接口。
 * PDO 提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据。
 */
class Db
{
    //数据库的默认连接参数
    private $dbConfig=[
        'db' => 'mysql',//数据库类型
        'host' => 'localhost',//主机名称
        'port' => '3306',//默认端口
        'user' => 'root',//用户名
        'pass' => 'root',//密码
        'db' => 'myblog',//数据库名称
        'charset' => 'utf8',//设置默认字符集
    ];
    //新增的主键id
    public $insertId = null;
    //受影响的记录数
    public $num = 0;
// 使用单例模式，本类的实例
    private  static $instance = null;

//数据库的连接
    private $conn = null;//初始化连接参数
/*
 * 构造方法私有化，防止外部实例化
 * */
    private function __constructe($params){
        //初始化连接参数
        $this->dbConfig = array_merge($this->dbConfig,$params);
        //连接数据库
        $this->connect();

    }
    /*
     * 克隆方法私有化
     * */
    private function __clone(){

    }
    public static function geInstance(){
        if(!self::$instance instanceof self){
            self::$instance = new self();
        }
        return self::$instance;
    }
    private function connect(){
        try{
            //配置数据源
            $dsn = "{$this->dbConfig['db']};host={$this->dbConfig['host']};port={$this->dbConfig['port']};
            dbname={$this->dbConfig['db']};charset={$this->dbConfig['charset']};";
            //创建PDO对象
            $this->conn = new PDO($dsn,$this->dbConfig['user'],$this->dbConfig['pass']);
            //设置默认字符集
            $this->conn->query("SET NAMES {$this->dbConfig['charset']}");
        }catch (PDOException $e){
            die('数据库连接失败'.$e->getMessage());
        }
    }
    //完成数据库的读写操作：增改
    ///返回受影响的记录，如果新增返回新增id
    public function  exec($sql){
        //如果有受影响的记录
        $num=$this->conn->exec($sql);
        if($num>0){
            //如果是新增操作，初始化新增主键id属性
            if(null !== $this->conn->lastInsertId()){
                $this->insertId =$this->conn->lastInsertId();
            }
            $this->num = $num;
        }else{
            $error = $this->conn->errorInfo();//获取最后操作的错误信息的数据
            //[0]错误标识符 [1]错误代码 [2]错误信息
            print '操作失败'.$error[0].':'.$error[1].':'.$error[2];
        }
    }
    //获取单条查询结果
    public function fetchAll($sql){
        $this->conn->query($sql)-$this->fetch(PDO::FETCH_ASSOC);
    }
}
```
待更新
-----