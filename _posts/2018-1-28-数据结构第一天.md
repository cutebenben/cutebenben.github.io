---
layout: post
title: '数据结构学习（不定期更新）'
subtitle: '考虑了很久还是准备把数据结构从头到尾重新学一次。'
date: 2018-3-6
categories: 数据结构
cover: 'https://warrest.github.io/wArrest.github.io/assets/img/data/1338730837_2482.png'
tags: 数据结构 学习
---

第一天
----

### 顺序存储方法
顺序存储方法是把逻辑地址相邻的数据元素存储在物理地址相邻的存储单元中
顺序存储结构是一种最基本的存储表示方法。一般借助于程序设计语言中的*数组*来实现。
### 链式存储方法
链式存储方法是不要求逻辑地址相邻的元素其物理地址也相邻，元素间的逻辑关系通过*附加指针*来表示，由此得到的数据存储方法为链式存储结构。

抽象数据类型形式定义为：
ADT 抽象数据类型{
  数据对象：数据对象的定义
  数据关系：数据关系的定义
  基本操作：基本操作的定义

}

### 数据结构 + 算法 = 程序

2018年3月4日15:15:29
----
### malloc函数动态分配内存
首先了解malloc函数：其实就是**开辟内存**

比如：
```c
int *p;//定义一个指针变量
p = （int*）malloc(100*sizeof(int));
//这里开辟出了100个int单元，400个字节，这里的p指向第一个元素
```
### 动态分配内存的好处
#### 1.程序运行的过程中，根据用户的需求，动态地构造不同长度的数组
#### 2.可以在程序运行的过程中释放它，节省内存
示例：
```c
#include <stdio.h>
#include <malloc.h>
int main(void){
	int a[5]={1,2,3,4,5};//静态数组，没有使用malloc函数的都属于静态数组
	int len;
	printf("请输入数组长度：len= ");
	scanf("%d",len);
	int * pArr = (int *)malloc(sizeof(int)*len);
	//定义一个类型为整形的指针变量，动态分配内存 
	*pArr = 4;//类似于a[0]=4 
	pArr[1] = 10;//类似于a[1]=10 
	printf("%d %d",*pArr,pArr[1]); 
	free(pArr);//将动态分配的20个字节内存释放 
	return 0; 
	 
}
```
### 2018年3月6日19:33:40  跨函数使用内存例子
```C++
#include <stdio.h>
#include <malloc.h>
/*
跨函数使用内存 
*/
struct Student{
	int sid;
	int age;
};
struct Student * CreateStudent(void);//声明一个类型为，，的指针变量 
void ShowStudent(struct Student *);
int main(void){
	int i =0;
	struct Student *pst;
	pst=CreateStudent();
	//printf("d%d%",pst->sid,pst->age);
//	for(i=0;i<3;i++){
		ShowStudent(pst);
//		printf("%d",pst);
//	}
	
	return 0;
}
struct Student * CreateStudent(void){
	struct Student *temp = (struct Student *)malloc(sizeof(struct Student));
	temp->sid=123;
	temp->age=22;
	return temp;
	free(temp);
}
void ShowStudent(struct Student *pst){
	printf("学号是%d,年龄是%d\n",pst->sid,pst->age);
}
```


### 2018年3月6日18:16:03
#### 线性结构：
1.数组【顺序结构】
实例：
```C++
#include <stdio.h>
#include <malloc.h>//包含了malloc 
#include <stdlib.h> //包含了exit 
//定义了一个数据类型，该数据类型的名字为struct Arr，并没有定义变量 
 struct Arr{
 	int * pBase;//存储的数组第一个元素的首地址 
 	int len;//数组容纳你元素的个数
 	int cnt;//当前数组有效元素的个数
	//int increment;//自动增长因子 
 };
void init_arr(struct Arr *pArr,int len);//初始化 
bool is_empty(struct Arr *pArr);
void show_arr(struct Arr *pArr);
/* 
bool append_arr();//追加
bool insert_arr();
bool delete_arr();
bool get();
bool is_full();
void sort_arr();
void inversion_arr(); 

*/

int main(void){
 	struct Arr arr;
	init_arr(&arr,6);//传递arr的地址，初始化后指向一个数组，初始化前三个成员都是垃圾数字  
 	//printf("%d",arr.len);
 	show_arr(&arr);
	 return 0;
}
void init_arr(struct Arr *pArr,int len){
	
 	pArr->pBase = (int *)malloc(len*sizeof(int));	
 	//如果分配失败 
 	if(NULL == pArr->pBase){
	 	printf("动态内存分配失败！");
		exit(-1);//终止程序 ,需要stdlib.h头文件 
	 }
	 else{
 		pArr->len = len;
 		pArr->cnt = 0;
 	} 
 	return;
}
  
bool is_empty(struct Arr *pArr){
 	if(0 == pArr->cnt){
	 	return true;
	 }
 	else{
	 	return false;
	 }
}
 
void show_arr(struct Arr *pArr){
	if(is_empty	(pArr)){
	 	printf("该数组为空！\n");
	 }
 	else{
 		for(int i=0;i<pArr->cnt;i++){
		 	printf("%d",pArr->pBase[i]);
		 	//int * 
		 }	
 	}
}

```
4.2.链表【】3.栈【】4.树
